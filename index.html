<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wochentag Rechner</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding: 2rem; background:#f7f8fb; color:#111; }
    .card { background: #fff; padding: 1.25rem; border-radius: 10px; box-shadow: 0 6px 18px rgba(20,30,50,0.06); max-width:560px; margin:auto; }
    label { display:block; margin-top:0.75rem; font-weight:600; }
    .row { display:flex; gap:.5rem; margin-top:.5rem; }
    input[type="number"], select { padding:.5rem; border:1px solid #d6dbe8; border-radius:8px; font-size:1rem; width:100%; box-sizing:border-box; }
    button { margin-top:1rem; padding:.6rem .9rem; border-radius:8px; border:0; background:#2563eb; color:white; font-weight:600; cursor:pointer; }
    button.secondary { background:#6b7280; }
    .result { margin-top:1rem; font-size:1.25rem; font-weight:700; }
    .hint { color:#555; margin-top:.5rem; font-size:.9rem; }
    .bad { color:#b91c1c; font-weight:700; }
  </style>
  <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
<meta name="apple-mobile-web-app-title" content="Dayfinder" />
<link rel="manifest" href="/site.webmanifest" />

</head>
<body>
  <main class="card" role="main">
    <h1>Wochentag Rechner</h1>
    <p class="hint">Gib ein Datum ein (unterstützt standardmäßig ±100 Jahre um das aktuelle Jahr). Schaltjahre folgen der gregorianischen Regel (Jahr %4, %100, %400).</p>

    <label for="day">Tag</label>
    <div class="row">
      <input id="day" type="number" min="1" max="31" value="1" />
      <select id="month" aria-label="Monat">
        <option value="1">Januar</option>
        <option value="2">Februar</option>
        <option value="3">März</option>
        <option value="4">April</option>
        <option value="5">Mai</option>
        <option value="6">Juni</option>
        <option value="7">Juli</option>
        <option value="8">August</option>
        <option value="9">September</option>
        <option value="10">Oktober</option>
        <option value="11">November</option>
        <option value="12">Dezember</option>
      </select>
    </div>

    <label for="year">Jahr</label>
    <input id="year" type="number" />

    <div class="row" style="margin-top:.75rem;">
      <button id="calc">Wochentag berechnen</button>
      <button id="today" class="secondary" type="button">Heute</button>
      <button id="prev" class="secondary" type="button" title="Vortag">◀</button>
      <button id="next" class="secondary" type="button" title="Nächster Tag">▶</button>
    </div>

    <p class="hint" id="rangeHint"></p>
    <p id="message" class="bad" aria-live="polite"></p>
    <div class="result" id="result" aria-live="polite"></div>
  </main>

  <script>
    (function() {
      // Deutsche Wochentagsnamen (Sonntag..Samstag)
      const weekdays = ["Sonntag","Montag","Dienstag","Mittwoch","Donnerstag","Freitag","Samstag"];

      // Hilfsfunktion: prüft gregorianisches Schaltjahr (inkl. Jahrhundertregel)
      function isLeapYear(y) {
        // y kann negativ sein (vor Christus) — wir behandeln die mathematische Regel identisch
        return (y % 4 === 0) && (y % 100 !== 0 || y % 400 === 0);
      }

      // Zeller's Kongruenz (für Gregorianischen Kalender)
      // Gibt 0=Samstag,1=Sonntag,...,6=Freitag zurück — wir passen nach Deutsch 0=Sonntag...
      // Quelle: klassische Zeller-Formel; wir passen die Monats-/Jahresverschiebung für Jan/Feb an.
      function zellersCongruence(day, month, year) {
        let q = day;
        let m = month;
        let Y = year;
        if (m === 1 || m === 2) { // Januar/Februar behandeln als Monat 13/14 des Vorjahres
          m += 12;
          Y -= 1;
        }
        const K = Y % 100;
        const J = Math.floor(Y / 100);
        // Zeller-Formel (Gregorian)
        const h = (q + Math.floor((13*(m+1))/5) + K + Math.floor(K/4) + Math.floor(J/4) + 5*J) % 7;
        // h: 0=Samstag,1=Sonntag,2=Montag,...,6=Freitag
        // Wir wandeln in 0=Sonntag..6=Samstag:
        const dayIndex = (h + 6) % 7;
        return dayIndex;
      }

      // Prüft, ob Datum existiert (monatsabhängig, Schaltjahr berücksichtigen)
      function validateDate(d, m, y) {
        if (!Number.isInteger(d) || !Number.isInteger(m) || !Number.isInteger(y)) return false;
        if (m < 1 || m > 12) return false;
        if (d < 1) return false;
        const mdays = [31, (isLeapYear(y) ? 29 : 28), 31,30,31,30,31,31,30,31,30,31];
        return d <= mdays[m-1];
      }

      // Elemente
      const dayEl = document.getElementById('day');
      const monthEl = document.getElementById('month');
      const yearEl = document.getElementById('year');
      const calcBtn = document.getElementById('calc');
      const resultEl = document.getElementById('result');
      const messageEl = document.getElementById('message');
      const rangeHint = document.getElementById('rangeHint');
      const todayBtn = document.getElementById('today');
      const prevBtn = document.getElementById('prev');
      const nextBtn = document.getElementById('next');

      // Standardbereich: +/- 100 Jahre um aktuelles Jahr (nur als Info)
      const now = new Date();
      const currentYear = now.getFullYear();
      const minYear = currentYear - 100;
      const maxYear = currentYear + 100;
      rangeHint.textContent = `Standardbereich (Info): ${minYear} bis ${maxYear}. Du kannst aber beliebige Jahreszahlen eingeben.`;

      // Setze heutiges Datum initial
      function setDateTo(d) {
        dayEl.value = d.getDate();
        monthEl.value = d.getMonth() + 1;
        yearEl.value = d.getFullYear();
        resultEl.textContent = '';
        messageEl.textContent = '';
      }
      setDateTo(now);

      // Kernfunktion: berechne, validiere, zeige Ergebnis
      function calculateAndShow() {
        messageEl.textContent = '';
        resultEl.textContent = '';

        // Lese Werte
        const d = parseInt(dayEl.value, 10);
        const m = parseInt(monthEl.value, 10);
        const y = parseInt(yearEl.value, 10);

        // Validierung
        if (!Number.isFinite(d) || !Number.isFinite(m) || !Number.isFinite(y)) {
          messageEl.textContent = 'Bitte Tag, Monat und Jahr korrekt eingeben.';
          return;
        }
        // Optional: weichen Hinweis, wenn Jahr weit außerhalb des ±100 Bereichs
        if (y < minYear || y > maxYear) {
          messageEl.textContent = `Hinweis: Jahr liegt außerhalb des Bereichs ${minYear}–${maxYear}. Die Berechnung verwendet den gregorianischen Algorithmus.`;
        }

        if (!validateDate(d, m, y)) {
          messageEl.textContent = 'Dieses Datum ist ungültig (z. B. 31. April oder 29. Februar in einem Nicht-Schaltjahr).';
          return;
        }

        // Berechne Wochentag mit Zeller
        const idx = zellersCongruence(d, m, y);
        const dayName = weekdays[idx];

        // Ausgabe mit formatierter Darstellung
        const monthNames = ["Januar","Februar","März","April","Mai","Juni","Juli","August","September","Oktober","November","Dezember"];
        resultEl.textContent = `${d}. ${monthNames[m-1]} ${y} → ${dayName}`;
      }

      // Buttons
      calcBtn.addEventListener('click', calculateAndShow);
      todayBtn.addEventListener('click', () => setDateTo(new Date()));

      // Hilfsfunktionen: inkrementiere/dekrementiere Datum
      function getDateFromInputs() {
        return { d: parseInt(dayEl.value,10), m: parseInt(monthEl.value,10), y: parseInt(yearEl.value,10) };
      }
      function setInputsFromDateObj(obj) {
        dayEl.value = obj.d;
        monthEl.value = obj.m;
        yearEl.value = obj.y;
      }
      function addDays(delta) {
        const { d, m, y } = getDateFromInputs();
        // Baue ein JS Date-Objekt (monat-1), manipuliere UTC um Zeitzone-Effekte zu vermeiden
        // JS Date unterstützt Jahre außerhalb ±100, so wir müssen etwas vorsichtig sein.
        // Wir erstellen Date in local zone but operate by milliseconds.
        const jsDate = new Date(y, m-1, d);
        jsDate.setDate(jsDate.getDate() + delta);
        setInputsFromDateObj({ d: jsDate.getDate(), m: jsDate.getMonth()+1, y: jsDate.getFullYear() });
        calculateAndShow();
      }
      prevBtn.addEventListener('click', () => addDays(-1));
      nextBtn.addEventListener('click', () => addDays(1));

      // Enter-Taste löst Berechnung aus
      [dayEl, monthEl, yearEl].forEach(el => {
        el.addEventListener('keydown', (ev) => {
          if (ev.key === 'Enter') calculateAndShow();
        });
      });

      // Beispieltests in Kommentarform (du kannst sie im Browser-Dev-Console nachprüfen):
      // 1 Jan 2000 = Samstag
      // 29 Feb 2000 = Dienstag (2000 ist Schaltjahr, weil %400)
      // 28 Feb 1900 = Mittwoch, 1 Mar 1900 = Donnerstag (1900 ist kein Schaltjahr)
      // 31 Oct 2025 = ?
    })();
  </script>
</body>
</html>
